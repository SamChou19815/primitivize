use std::str::FromStr;
// use base::pos::{self, BytePos, Spanned};
use crate::ast::{
  LiteralValue,
  FunctionCategory,
  BinaryOperator,
  ExpressionStaticType,
  SourceLanguageExpression,
  SourceLanguageMutableGlobalVariableDefinition,
  SourceLanguageFunctionDefinition,
  SourceLanguageProgram,
};

grammar;

Comma<T>: Vec<T> = { // (1)
  <v:(<T> ",")*> <e:T?> => match e { // (2)
      None => v,
      Some(e) => {
          let mut v = v;
          v.push(e);
          v
      }
  }
};

Semicolon<T>: Vec<T> = { // (1)
  <v:(<T> ";")*> <e:T?> => match e { // (2)
      None => v,
      Some(e) => {
          let mut v = v;
          v.push(e);
          v
      }
  }
};

LiteralValue: LiteralValue = {
  r"[0-9]+" => LiteralValue::IntLiteral(i32::from_str(<>).unwrap()),
  "true" => LiteralValue::BoolLiteral(true),
  "false" => LiteralValue::BoolLiteral(false),
}

ExpressionStaticType: ExpressionStaticType = {
  "void" => ExpressionStaticType::VoidType,
  "int" => ExpressionStaticType::IntType,
  "bool" => ExpressionStaticType::BoolType,
}

Identifier: String = "r[a-z][A-Za-z0-9]*" => <>.to_string();

SimpleExpression : SourceLanguageExpression = {
  <l:@L> <literal:LiteralValue> => SourceLanguageExpression::LiteralExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    literal: literal,
  },
  <l:@L> <identifier: Identifier> => SourceLanguageExpression::VariableExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    identifier,
  },
  "(" <e: SourceLanguageExpression> ")" => e,
}

NotExpression : SourceLanguageExpression = {
  <l:@L> "!" <e: NotExpression> => SourceLanguageExpression::NotExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    sub_expression: Box::new(e)
  },
  SimpleExpression,
}

FunctionCallExpression : SourceLanguageExpression = {
  <l:@L> <function_name: Identifier> "("
  <function_arguments: Comma<SourceLanguageExpression>>
  ")" => SourceLanguageExpression::FunctionCallExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    function_name,
    function_arguments,
  },
  NotExpression,
}

FactorOp: BinaryOperator = {
  "*" => BinaryOperator::MUL,
  "/" => BinaryOperator::DIV,
  "%" => BinaryOperator::MOD,
}

FactorExpression : SourceLanguageExpression = {
  <l:@L> <e1: FactorExpression> <op: FactorOp> <e2: FunctionCallExpression>
  => SourceLanguageExpression::BinaryExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    operator: op,
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  FunctionCallExpression,
}

TermOp: BinaryOperator = {
  "+" => BinaryOperator::PLUS,
  "-" => BinaryOperator::MINUS,
}

TermExpression : SourceLanguageExpression = {
  <l:@L> <e1: TermExpression> <op: TermOp> <e2: FactorExpression>
  => SourceLanguageExpression::BinaryExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    operator: op,
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  FactorExpression,
}

ComparisonOp: BinaryOperator = {
  "<" => BinaryOperator::LT,
  "<=" => BinaryOperator::LE,
  ">" => BinaryOperator::GT,
  ">=" => BinaryOperator::GE,
  "==" => BinaryOperator::EQ,
  "!=" => BinaryOperator::NE,
}

ComparisonExpression : SourceLanguageExpression = {
  <l:@L> <e1: ComparisonExpression> <op: ComparisonOp> <e2: TermExpression>
  => SourceLanguageExpression::BinaryExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    operator: op,
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  TermExpression,
}

ConjunctionExpression : SourceLanguageExpression = {
  <l:@L> <e1: ConjunctionExpression> "&&" <e2: ComparisonExpression>
  => SourceLanguageExpression::BinaryExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    operator: BinaryOperator::AND,
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  ComparisonExpression,
}

DisjunctionExpression : SourceLanguageExpression = {
  <l:@L> <e1: DisjunctionExpression> "||" <e2: ConjunctionExpression>
  => SourceLanguageExpression::BinaryExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    operator: BinaryOperator::OR,
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  ConjunctionExpression,
}

IfElseExpression : SourceLanguageExpression = {
  <l:@L> "if" <c: SourceLanguageExpression> "then"
    <e1: IfElseExpression>
  "else"
    <e2: IfElseExpression>
  => SourceLanguageExpression::IfElseExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    condition: Box::new(c),
    e1: Box::new(e1),
    e2: Box::new(e2),
  },
  DisjunctionExpression,
}

AssignExpression : SourceLanguageExpression = {
  <l:@L> <identifier: Identifier> "=" <e: IfElseExpression>
  => SourceLanguageExpression::AssignmentExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    identifier,
    assigned_expression: Box::new(e),
  },
  IfElseExpression,
}

SourceLanguageExpression : SourceLanguageExpression = {
  <l:@L> "{" <expressions: Semicolon<SourceLanguageExpression>> "}"
  => SourceLanguageExpression::ChainExpression {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    expressions,
  },
  AssignExpression,
}

SourceLanguageMutableGlobalVariableDefinition : SourceLanguageMutableGlobalVariableDefinition = {
  <l:@L> "var" <identifier: Identifier> "=" <e: SourceLanguageExpression>
  => SourceLanguageMutableGlobalVariableDefinition {
    line_number: l,
    static_type: ExpressionStaticType::VoidType,
    identifier,
    assigned_expression: e,
  }
};

FunctionArgument: (String, ExpressionStaticType) =
  <identifier: Identifier> ":" <t: ExpressionStaticType> => (identifier, t);

SourceLanguageFunctionDefinition : SourceLanguageFunctionDefinition = {
  <l:@L> "fun" <identifier: Identifier> "("
  <function_arguments: Comma<FunctionArgument>>
  ")" ":" <return_type: ExpressionStaticType> "=" <e: SourceLanguageExpression>
  => SourceLanguageFunctionDefinition {
    line_number: l,
    category: FunctionCategory::UserDefined,
    identifier,
    function_arguments,
    return_type,
    body: e,
  }
}

pub SourceLanguageProgram : SourceLanguageProgram = {
  <global_variable_definitions: SourceLanguageMutableGlobalVariableDefinition*>
  <function_definitions: SourceLanguageFunctionDefinition*>
  => SourceLanguageProgram {
    global_variable_definitions,
    function_definitions,
  }
}
